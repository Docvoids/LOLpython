Інтерпретатор LOLCODE на Python

Автор: Гордієнко Роман, Лаврик Севастьян, Ухалов Олексій

1. Вступ

Цей документ описує архітектуру та дизайн інтерпретатора для езотеричної мови програмування LOLCODE, реалізованого на мові Python. Проєкт складається з чотирьох основних компонентів: лексера, парсера, набору вузлів Абстрактного Синтаксичного Дерева (AST) та інтерпретатора, що виконує це дерево.

Мета проєкту — створити працездатний інтерпретатор, що підтримує основні конструкції мови LOLCODE версії 1.2, включаючи змінні, арифметичні операції, умовні конструкції, масиви (BUKKITs), функції та базову підтримку класів і об'єктів.
1.2. Цільова аудиторія

Цей документ призначений для розробників, які працюють над проєктом, а також для тих, хто бажає зрозуміти його внутрішню будову, принципи роботи та потенційні шляхи для розширення.
2. 
3. Цілі та Не-цілі

2.1. Цілі

    Реалізація ключових можливостей LOLCODE 1.2:

        Оголошення та присвоєння змінних (I HAS A, ITZ, R).

        Базові типи даних: NUMBR (числа), YARN (рядки), TROOF (булеві), NOOB (null).

        Арифметичні операції (SUM OF, DIFF OF, PRODUKT OF, QUOSHUNT OF).

        Операції порівняння (BOTH SAEM, DIFFRINT).

        Вивід у консоль (VISIBLE).

        Умовні конструкції (O RLY?, YA RLY, NO WAI, OIC).

        Функції (HOW IZ I, IF U SAY SO, FOUND YR).

        Масиви (BUKKIT), доступ до елементів ('Z ITZ) та отримання розміру (MAEK ... A NUMBR).

        Класи (HOW DUZ I, KTHX), створення екземплярів (A NEW), доступ до полів та методів ('Z), посилання на екземпляр (ME).

    Чітка архітектура: Створення модульної системи, де кожен компонент (лексер, парсер, інтерпретатор) має чітко визначену відповідальність.

    Зрозуміла обробка помилок: Надання інформативних повідомлень про помилки на етапах лексичного, синтаксичного аналізу та виконання.

2.2. Не-цілі

    Повна відповідність специфікації LOLCODE 1.2: Деякі складніші або менш уживані частини специфікації (напр., конструкція WTF?, розширені операції MAEK, оператор SMOOSH для конкатенації рядків) наразі не реалізовані.

    Висока продуктивність: Проєкт є інтерпретатором, що "проходить" по дереву (tree-walking interpreter). Оптимізація продуктивності не є пріоритетом.

    Компіляція: Проєкт не компілює код у байт-код чи машинний код. Він виконує його безпосередньо з AST.

    Розширена стандартна бібліотека: Відсутня реалізація функцій для роботи з файлами, мережею тощо.


3. Дизайн Компонентів

3.1. Лексер (lexer.py)

    Реалізація: Клас Lexer, який використовує регулярні вирази (re) для зіставлення токенів.

    Основний метод: tokenize(), який повертає список об'єктів Token.

    Токен: collections.namedtuple('Token', ['type', 'value', 'line', 'column']). Зберігає тип, значення та позицію токена для точної діагностики помилок.

    Ключові рішення:

        Розділення NEWLINE та SKIP (пробіли/табуляція). Це дозволяє парсеру використовувати NEWLINE як значущий роздільник виразів та блоків коду.

        Використання списку специфікацій (TYPE, regex) забезпечує пріоритетність (наприклад, O RLY? буде розпізнано раніше, ніж IDENTIFIER).

3.2. Вузли AST (ast_nodes.py)

    Реалізація: Модуль визначає структуру AST за допомогою dataclasses.

    Ієрархія:

        ASTNode (базовий клас)

            StatementNode (інструкції, що не повертають значення)

            ExpressionNode (вирази, що обчислюються в значення)

    Приклади вузлів:

        ProgramNode: Кореневий вузол, містить список інструкцій.

        BinaryOpNode: Представляє бінарну операцію (left, op, right).

        IfNode: Представляє умовну конструкцію з гілками if_block та else_block.

        BukkitAccessNode: Доступ до елемента масиву (bukkit, index).

    Ключові рішення: Використання dataclasses робить код чистим, декларативним і усуває необхідність писати шаблонні __init__ методи.

3.3. Парсер (parser.py)

    Тип парсера: Рекурсивний спуск (Recursive Descent Parser).

    Структура: Клас Parser з методами, що відповідають правилам граматики мови (напр., _parse_statement(), _parse_expression()).

    Основний метод: parse(), який повертає кореневий вузол AST (ProgramNode).

    Ключові рішення:

        Обробка виразів: Використовується класичний підхід з розділенням на _parse_expression (для бінарних операторів) та _parse_primary ( для атомів, як-от літерали, змінні), а також _parse_postfix_expression для обробки постфіксних операцій (виклик функції, доступ до члена).

        Обробка A BUKKIT: В _parse_primary спеціально обробляється ідентифікатор 'A', оскільки він є частиною синтаксису створення масиву, а не звичайною змінною.

        Обробка пробілів: Метод _consume_whitespace() використовується для пропуску несуттєвих токенів NEWLINE та COMMENT, що спрощує логіку парсингу блоків.

3.4. Інтерпретатор (interpreter.py)

    Архітектурний патерн: "Відвідувач" (Visitor). Метод interpret() динамічно викликає спеціалізований метод _visit_<NodeName>() для кожного типу вузла AST.

    Управління станом:

        Область видимості (Scope): Клас Scope реалізує лексичну область видимості. Кожен екземпляр Scope має посилання на батьківську область (parent). Пошук змінної (get) відбувається по ланцюжку від поточної області до глобальної.

        Стек викликів: Неявний, реалізується через рекурсивні виклики Python під час обходу дерева.

        Стан інтерпретатора: current_scope та current_instance (для ME) зберігають поточний контекст виконання.

    Ключові рішення:

        Повернення з функцій (ReturnSignal): Для реалізації оператора FOUND YR (return) використовується механізм винятків. ReturnSignal кидається всередині функції і перехоплюється в методі _execute_function. Це стандартний та ефективний спосіб реалізації нелокального потоку управління.

        Представлення об'єктів:

            LOLInstance: Райнтайм-об'єкт, що представляє екземпляр класу. Він містить посилання на визначення класу (class_def) та словник полів (fields).

            LOLCallable: Об'єкт, що представляє функцію або метод, який можна викликати. Він "загортає" FuncDefNode і, для методів, посилання на екземпляр (instance).

        Логіка "істинності": У _visit_IfNode реалізовано правило LOLCODE: FAIL та NOOB є хибними, решта значень — істинними.

4. Потік Даних (Приклад)

Розглянемо виконання коду: I HAS A myArr ITZ A BUKKIT.

    Лексер: Генерує токени: [Token(I_HAS_A, ...), Token(IDENTIFIER, 'myArr'), Token(ITZ, ...), Token(IDENTIFIER, 'A'), Token(BUKKIT, ...)].

    Парсер:

        _parse_statement() бачить I_HAS_A і викликає _parse_var_decl().

        _parse_var_decl() розпізнає myArr як ім'я, бачить ITZ і викликає _parse_expression().

        _parse_expression() викликає _parse_primary().

        _parse_primary() бачить IDENTIFIER 'A', а за ним BUKKIT. Він розпізнає цю комбінацію і створює ast.BukkitNode().

        У результаті парсер створює вузол: ast.VarDeclNode(name='myArr', initializer=ast.BukkitNode()).

    Інтерпретатор:

        interpret() викликає _visit_VarDeclNode().

        Цей метод спочатку обробляє ініціалізатор: викликає interpret(node.initializer), що призводить до виклику _visit_BukkitNode().

        _visit_BukkitNode() повертає порожній список Python [].

        _visit_VarDeclNode() отримує цей список і викликає self.current_scope.set('myArr', []).

        У поточній області видимості з'являється змінна myArr зі значенням [].

5. Обробка Помилок (errors.py)

Система використовує ієрархію власних класів винятків:

    LOLPythonError: Базовий клас для всіх помилок проєкту.

    LexerError: Помилка на етапі лексичного аналізу (невідомий символ).

    ParserError: Помилка на етапі синтаксичного аналізу (неочікуваний токен, порушення граматики).

    InterpreterError: Помилка під час виконання (ділення на нуль, звернення до неоголошеної змінної).

Такий підхід дозволяє main.py перехоплювати всі специфічні для інтерпретатора помилки в одному блоці try...except LOLPythonError as e і виводити користувачу зрозуміле повідомлення.